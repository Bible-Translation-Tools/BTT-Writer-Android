package com.door43.translationstudio.rendering;

import android.graphics.Typeface;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.TextUtils;
import android.text.style.StyleSpan;

import com.door43.translationstudio.spannables.NoteSpan;
import com.door43.translationstudio.spannables.Span;
import com.door43.translationstudio.spannables.VersePinSpan;
import com.door43.translationstudio.spannables.VerseSpan;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This is the USX rendering engine. This handles all of the rendering for USX formatted source and translation
 * NOTE: when rendering large chunks of text it is important to always keep things as a CharSequence and not string
 * so that spans generated by prior rendering methods are not lost.
 */
public class USXRenderer extends RenderingEngine {

    private Span.OnClickListener mNoteListener;
    private Span.OnClickListener mVerseListener;
    private boolean mRenderVerses = true;
    private int[] mExpectedVerseRange = new int[0];

    /**
     * Creates a new usx rendering engine without any listeners
     */
    public USXRenderer() {

    }

    /**
     * Creates a new usx rendering engine with some custom click listeners
     * @param verseListener
     */
    public USXRenderer(Span.OnClickListener verseListener, Span.OnClickListener noteListener) {
        mVerseListener = verseListener;
        mNoteListener = noteListener;
    }

    /**
     * if set to false verses will not be displayed in the output.
     *
     * @param enable default is true
     */
    public void setVersesEnabled(boolean enable) {
        mRenderVerses = enable;
    }

    /**
     * Specifies an inclusive range of verses expected in the input.
     * If a verse is not found it will be inserted at the front of the input.
     * @param verseRange
     */
    public void setPopulateVerseMarkers(int[] verseRange) {
        mExpectedVerseRange = verseRange;
    }

    /**
     * Renders the usx input into a readable form
     * @param in the raw input string
     * @return
     */
    @Override
    public CharSequence render(CharSequence in) {
        CharSequence out = in;

        out = trimWhitespace(out);
        out = renderSectionHeading(out);
        out = renderLineBreaks(out);
        // TODO: this will strip out new lines. Eventually we may want to convert these to paragraphs.
        out = renderWhiteSpace(out);
        out = renderParagraph(out);
        out = renderBlankLine(out);
        out = renderPoeticLine(out);
        out = renderVerse(out);
        out = renderNote(out);
        out = renderChapterLabel(out);

        return out;
    }

    /**
     * Strips out new lines and replaces them with a single space
     * @param in
     * @return
     */
    public CharSequence trimWhitespace(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = Pattern.compile("(^\\s*|\\s*$)");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), "");
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders section headings.
     * For now these are just ignored (hidden)
     * @param in
     * @return
     */
    public CharSequence renderSectionHeading(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = paraPattern("s");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            // strip out section heading
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()));
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Strips out extra whitespace from the text
     * @param in
     * @return
     */
    public CharSequence renderWhiteSpace(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = Pattern.compile("(\\s+)");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), " ");
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }
    
    /**
     * Strips out new lines and replaces them with a single space
     * @param in
     * @return
     */
    public CharSequence renderLineBreaks(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = Pattern.compile("(\\s*\\n+\\s*)");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), " ");
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders all note tags
     * @param in
     * @return
     */
    public CharSequence renderNote(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = Pattern.compile(NoteSpan.PATTERN);
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            NoteSpan note = NoteSpan.parseNote(matcher.group());
            if(note != null) {
                note.setOnClickListener(mNoteListener);
                out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), note.toCharSequence());
            } else {
                // failed to parse the note
                out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.end()));
            }

            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders all verse tags
     * @param in
     * @return
     */
    public CharSequence renderVerse(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = Pattern.compile(VerseSpan.PATTERN);
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        List<Integer> foundVerses = new ArrayList<>();
        while(matcher.find()) {
            if(isStopped()) return in;
            if(mRenderVerses) {
                Span verse;
                if(mVerseListener == null) {
                    verse = new VerseSpan(matcher.group(1));
                } else {
                    verse = new VersePinSpan(matcher.group(1));
                }

                if (verse != null) {
                    // record found verses
                    int startVerse = ((VerseSpan)verse).getStartVerseNumber();
                    int endVerse = ((VerseSpan)verse).getEndVerseNumber();
                    boolean alreadyRendered = false;
                    if(endVerse > startVerse) {
                        // range of verses
                        for(int i = startVerse; i <= endVerse; i ++) {
                            if(!foundVerses.contains(i)) {
                                foundVerses.add(i);
                            } else {
                                alreadyRendered = true;
                            }
                        }
                    } else {
                        if(!foundVerses.contains(startVerse)) {
                            foundVerses.add(startVerse);
                        } else {
                            alreadyRendered = true;
                        }
                    }
                    // render verses not already found
                    if(!alreadyRendered) {
                        // exclude verses not within the range
                        boolean invalidVerse = false;
                        if(mExpectedVerseRange.length > 0) {
                            int minVerse = mExpectedVerseRange[0];
                            int maxVerse = mExpectedVerseRange[1];
                            if(maxVerse == 0) maxVerse = minVerse;

                            int verseNumStart = ((VerseSpan) verse).getStartVerseNumber();
                            int verseNumEnd = ((VerseSpan) verse).getEndVerseNumber();
                            if(verseNumEnd == 0) verseNumEnd = verseNumStart;
                            invalidVerse = verseNumStart < minVerse || verseNumStart > maxVerse || verseNumEnd < minVerse || verseNumEnd > maxVerse;
                        }
                        if(!invalidVerse) {
                            verse.setOnClickListener(mVerseListener);
                            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), verse.toCharSequence());
                        } else {
                            // exclude invalid verse
                            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()));
                        }
                    } else {
                        // exclude duplicate verse
                        out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()));
                    }
                } else {
                    // failed to parse the verse
                    out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.end()));
                }
            } else {
                // exclude verse from display
                out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()));
            }
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));

        if(mRenderVerses) {
            // populate missing verses
            if (mExpectedVerseRange.length == 1) {
                if (!foundVerses.contains(mExpectedVerseRange[0])) {
                    // generate missing verse
                    Span verse;
                    if (mVerseListener == null) {
                        verse = new VerseSpan(mExpectedVerseRange[0]);
                    } else {
                        verse = new VersePinSpan(mExpectedVerseRange[0]);
                    }
                    verse.setOnClickListener(mVerseListener);
                    out = TextUtils.concat(verse.toCharSequence(), out);
                }
            } else if (mExpectedVerseRange.length == 2) {
                for (int i = mExpectedVerseRange[1]; i >= mExpectedVerseRange[0]; i--) {
                    if (!foundVerses.contains(i)) {
                        // generate missing verse
                        Span verse;
                        if (mVerseListener == null) {
                            verse = new VerseSpan(i);
                        } else {
                            verse = new VersePinSpan(i);
                        }
                        verse.setOnClickListener(mVerseListener);
                        out = TextUtils.concat(verse.toCharSequence(), out);
                    }
                }
            }
        }
        return out;
    }

    /**
     * Renders all paragraph tgs
     * @param in
     * @return
     */
    public CharSequence renderParagraph(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = paraPattern("p");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            String lineBreak = "";
            if(matcher.start() > 0) {
                lineBreak = "\n";
            }
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), lineBreak, "    ", in.subSequence(matcher.start(1), matcher.end(1)), "\n");
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders all blank line tags
     * @param in
     * @return
     */
    public CharSequence renderBlankLine(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = paraShortPattern("b");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), "\n\n");
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders a chapter label
     * @param in
     * @return
     */
    public CharSequence renderChapterLabel(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = paraPattern("cl");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while (matcher.find()) {
            if(isStopped()) return in;

            SpannableString span = new SpannableString(in.subSequence(matcher.start(1), matcher.end(1)));
            span.setSpan(new StyleSpan(Typeface.BOLD), 0, span.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            out = TextUtils.concat(out,  in.subSequence(lastIndex, matcher.start()), span);
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Renders all paragraph tags
     * @param in
     * @return
     */
    public CharSequence renderPoeticLine(CharSequence in) {
        CharSequence out = "";
        Pattern pattern = paraPattern("q(\\d+)");
        Matcher matcher = pattern.matcher(in);
        int lastIndex = 0;
        while(matcher.find()) {
            if(isStopped()) return in;
            int level = Integer.parseInt(matcher.group(1));
            SpannableString span = new SpannableString(in.subSequence(matcher.start(2), matcher.end(2)));
            span.setSpan(new StyleSpan(Typeface.ITALIC), 0, span.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            String padding = "";
            for(int i = 0; i < level; i ++) {
                padding += "    ";
            }

            // don't stack new lines
            String leadingLineBreak = "";
            String trailingLineBreak = "";

            // leading
            if(in.subSequence(0, matcher.start()) != null) {
                String previous = in.subSequence(0, matcher.start()).toString().replace(" ", "");
                int lastLineBreak = previous.lastIndexOf("\n");
                if (lastLineBreak < previous.length()) {
                    leadingLineBreak = "\n";
                }
            }

            // trailing
            if(in.subSequence(matcher.end(), in.length()) != null) {
                String next = in.subSequence(matcher.end(), in.length()).toString().replace(" ", "");
                int nextLineBreak = next.indexOf("\n");
                if (nextLineBreak > 0) {
                    trailingLineBreak = "\n";
                }
            }

            out = TextUtils.concat(out, in.subSequence(lastIndex, matcher.start()), leadingLineBreak, padding, span, trailingLineBreak);
            lastIndex = matcher.end();
        }
        out = TextUtils.concat(out, in.subSequence(lastIndex, in.length()));
        return out;
    }

    /**
     * Returns a pattern that matches a para tag pair e.g. <para style=""></para>
     * @param style a string or regular expression to identify the style
     * @return
     */
    private static Pattern paraPattern(String style) {
        return Pattern.compile("<para\\s+style=\""+style+"\"\\s*>\\s*(((?!</para>).)*)</para>", Pattern.DOTALL);
    }

    /**
     * Returns a pattern that matches a single para tag e.g. <para style=""/>
     * @param style a string or regular expression to identify the style
     * @return
     */
    private static Pattern paraShortPattern(String style) {
        return Pattern.compile("<para\\s+style=\""+style+"\"\\s*/>", Pattern.DOTALL);
    }
}
