package com.door43.translationstudio.newui.translate;

import android.os.Bundle;
import android.support.v7.widget.RecyclerView;
import android.view.ViewGroup;
import android.widget.SectionIndexer;

import com.door43.translationstudio.core.TranslationViewMode;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by joel on 9/18/2015.
 */
public abstract class ViewModeAdapter<VH extends RecyclerView.ViewHolder> extends RecyclerView.Adapter<VH>  implements SectionIndexer {
    private List<VH> mViewHolders = new ArrayList<>();
    private OnEventListener mListener;
    private int mStartPosition = 0;
    private String[] mSectionMarkers;
    private Integer[] mStartPositionForSection;
    private Integer[] mSectionForPosition;

    /**
     * Returns the viewholder generated by the child class so we can keep track of it
     * @param parent
     * @param viewType
     * @return
     */
    abstract VH onCreateManagedViewHolder(ViewGroup parent, int viewType);

    @Override
    public final VH onCreateViewHolder(ViewGroup parent, int viewType) {
        VH holder = onCreateManagedViewHolder(parent, viewType);
        mViewHolders.add(holder);
        return holder;
    }

    /**
     * Returns the start position where the list should start when first built
     * @return
     */
    protected int getListStartPosition() {
        return mStartPosition;
    }

    /**
     * Sets the position where the list should start when first built
     * @param startPosition
     */
    protected void setListStartPosition(int startPosition) {
        mStartPosition = startPosition;
    }

    /**
     * Returns the registered click listener
     * @return
     */
    protected OnEventListener getListener() {
        return mListener;
    }

    /**
     * Registeres the click listener
     * @param listener
     */
    public void setOnClickListener(OnEventListener listener) {
        mListener = listener;
    }

    /**
     * Notifies the adapter that it should rebuild it's view holders
     */
    abstract void rebuild();

    /**
     * Updates the source translation to be displayed
     * @param sourceTranslationId
     */
    abstract void setSourceTranslation(String sourceTranslationId);

    /**
     * Called when coordinating operations need to be applied to all the view holders
     * @param holder
     */
    abstract void onCoordinate(VH holder);

    /**
     * get the chapter ID for the position
     * @param position
     */
    public String getChapterID(int position) {
        int section = getSectionForPosition( position);

        int markersLength = mSectionMarkers.length;
        if( markersLength > 0 ) {
            if (section >= 0) {
                return mSectionMarkers[section];
            }
        }
        return "";
    }

    @Override
    public Object[] getSections() { // in our case these are chapters
        makeSureSectionMarkersInitialized();
        return mSectionMarkers;
    }

    @Override
    public int getPositionForSection(int sectionIndex) { // in our case we are finding where a chapter starts
        makeSureSectionMarkersInitialized();

        int length = mStartPositionForSection.length;
        if( length <= 0 ) {
            return 0;
        }

        if( sectionIndex < 0 ) { // limit input range
            sectionIndex = 0;
        } else {
            if( sectionIndex >= length) {
                sectionIndex = length - 1;
            }
        }

        return mStartPositionForSection[sectionIndex];
    }

    @Override
    public int getSectionForPosition(int position) {
        makeSureSectionMarkersInitialized();

        int posLength = mSectionForPosition.length;
        int markersLength = mSectionMarkers.length;
        if( (posLength <= 0) || (markersLength <= 0) ) {
            return 0;
        }

        if( position < 0 ) { // limit input range
            position = 0;
        } else {
            if( position >= posLength) {
                position = posLength - 1;
            }
        }

        int section = mSectionForPosition[position];

        if( section < 0 ) { // sanity check - limit output range
            section = 0;
        } else {
            if( section >= markersLength) {
                section = markersLength - 1;
            }
        }
        return section;
    }

    /**
     * clears the section markers so they will be regenerated
     */
    protected void resetSectionMarkers() {
        mSectionMarkers = null;
    }

    /**
     * if not yet cached, determine and cache the chapter boundaries
     */
    protected void makeSureSectionMarkersInitialized() {
        // TODO: 10/3/16 this needs to be cleaned up
        if(null == mSectionMarkers) {
            List<String> chapterMarkers = new ArrayList<>();
            List<Integer> sectionForPosition = new ArrayList<>();
            List<Integer> startPositionForSection = new ArrayList<>();
            int length = getItemCount();
            String lastChapter = "";
            int currentSection = -1;
            for (int i = 0; i < length; i++) {
                String chapter = getChapterForPosition(i);
                if(chapter == null) {
                    chapter = lastChapter;
                    if(chapter.isEmpty()) { //if we haven't seen a chapter marker yet, we will associate it with chapter 1
                        chapter = "01";
                    }
                }

                if(!lastChapter.equals(chapter)) {
                    if(lastChapter.isEmpty()) { //if we haven't seen a chapter marker yet, we will associate it with chapter 1
                        lastChapter = "0";
                    }
                    if(Integer.valueOf(chapter) - Integer.valueOf(lastChapter) == 1) { // make sure we have sequential chapters
                        chapterMarkers.add(chapter);
                        startPositionForSection.add(i);

                    } else { // we have skipped over chapters (could be due to string search)
                        int markerLength = chapter.length();
                        int startChapter = Integer.valueOf(lastChapter);
                        int endChapter = Integer.valueOf(chapter);
                        for(int ch = startChapter + 1; ch <= endChapter; ch++) {
                            String chapterStr = ("000" + String.valueOf(ch));
                            chapterStr = chapterStr.substring(chapterStr.length() - markerLength);
                            chapterMarkers.add(chapterStr);
                            startPositionForSection.add(i);
                        }
                    }
                    lastChapter = chapter;
                    currentSection = Integer.valueOf(chapter) - 1;
                }
                sectionForPosition.add(currentSection);
            }

            mSectionMarkers = chapterMarkers.toArray(new String[chapterMarkers.size()]);
            mStartPositionForSection = startPositionForSection.toArray(new Integer[startPositionForSection.size()]);
            mSectionForPosition = sectionForPosition.toArray(new Integer[sectionForPosition.size()]);
            OnEventListener listener = getListener();
            if(listener != null) {
                listener.onItemCountChanged(getItemCount(), 0);
            }
        }
    }

    /**
     * get the chapter for the position, or null if not found
     * @param position
     * @return
     */
    abstract String getChapterForPosition(int position);

    /**
     * Requests the layout manager to coordinate all visible children in the list
     */
    protected void coordinateViewHolders() {
        for(VH holder:mViewHolders) {
            onCoordinate(holder);
        }
    }

    /**
     * returns the frame at the given position
     * @param position
     * @return
     */
    public abstract String getFocusedFrameId(int position);

    /**
     * returns the frame at the given position
     * @param position
     * @return
     */
    public abstract String getFocusedChapterId(int position);

    /**
     * Returns the position of an item in the adapter.
     * @param chapterId
     * @param frameId
     * @return -1 if no item is found
     */
    public abstract int getItemPosition(String chapterId, String frameId);

    /**
     * Restarts the auto commit timer
     */
    public void restartAutoCommitTimer() {
        mListener.restartAutoCommitTimer();
    }

    /**
     * Notifies the adpater that it needs to reload all it's data.
     */
    public abstract void reload();

    public interface OnEventListener {
        void onSourceTranslationTabClick(String sourceTranslationId);
        void onNewSourceTranslationTabClick();
        void closeKeyboard();
        void openTranslationMode(TranslationViewMode mode, Bundle extras);
        void onTranslationWordClick(String translationWordId, int width);
        void onTranslationArticleClick(String volume, String manual, String slug, int width);
        void onTranslationNoteClick(String chapterId, String frameId, String translationNoteId, int width);
        void onCheckingQuestionClick(String chapterId, String frameId, String checkingQuestionId, int width);
        void scrollToFrame(String chapterSlug, String frameSlug);
        void restartAutoCommitTimer();
        void onSetBusyIndicator(boolean enable);
        void onItemCountChanged(int itemCount, int progress);
    }
}
